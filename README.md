# 1. Объекты Встроенные методы
## 1) Статические методы объекта
Статические методы объекта — это методы, которые принадлежат классу, а не экземплярам этого класса. Они не имеют доступа к атрибутам экземпляров класса и не требуют создания объекта класса для вызова. Статические методы обычно используются для выполнения каких-либо операций, связанных с классом, но не зависящих от его состояния.
Статические методы удобно использовать, когда требуется функциональность, связанная с классом, но не зависящая от его состояния.
```
class MathUtils {
  static add(a, b) {
    return a + b;
  }

  static subtract(a, b) {
    return a - b;
  }
}

// Вызов статических методов
console.log(MathUtils.add(5, 3));       // Вывод: 8
console.log(MathUtils.subtract(10, 4)); // Вывод: 6
```

## 2) Флаги и дескрипторы свойств
#### Дескрипторы свойств 
Флаги и дескрипторы свойств используются для определения и настройки поведения свойств объектов. Они позволяют управлять доступом, изменением и удалением свойств объектов. Вот краткое объяснение каждого из них:

Дескриптор свойства - это объект, который определяет характеристики свойства объекта, такие как:

* value: Значение свойства.

* writable: Можно ли изменять значение свойства.

* enumerable: Будет ли свойство перечисляемым в циклах.

* configurable: Можно ли удалять или изменять дескриптор свойства.

Пример использования дескрипторов свойств:
```
const obj = {};
Object.defineProperty(obj, 'prop', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});
```
#### Флаги 
Флаги свойств - это битовые флаги, которые определяют различные аспекты свойства, такие как:

* writable: Если установлен в false, значение свойства нельзя изменить.

* enumerable: Если установлен в false, свойство не будет перечисляемым в циклах.

* configurable: Если установлен в false, дескриптор свойства не может быть изменен или свойство удалено.

Пример использования флагов свойств:
```
const obj = {
  prop: 42
};
Object.defineProperty(obj, 'prop', {
  writable: false,
  enumerable: true,
  configurable: false
});
```
Использование дескрипторов свойств и флагов свойств позволяет точно настраивать поведение свойств объектов в JavaScript. 
Это может быть полезно, например, для создания "защищенных" свойств, которые нельзя случайно изменить, или для определения специфичных поведений при доступе к свойствам.

## 3) Итерируемые объекты, использование Symbol.iterator(optional)
Создание итерируемых объектов позволяет определить способ, каким образом объект будет перебираться с помощью цикла for...of, ...spread, и других механизмов итерации. 
Для этого используется символ Symbol.iterator.

Давайте рассмотрим пример создания итерируемого объекта:
```
const myIterable = {
  data: [1, 2, 3, 4, 5],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// Используем итерируемый объект
for (const item of myIterable) {
  console.log(item);
}
```
В этом примере объект myIterable становится итерируемым благодаря методу, связанному с символом Symbol.iterator. Метод next этого итератора возвращает объект с двумя свойствами: value (значение текущего элемента) и done (логическое значение, показывающее, закончен ли перебор). Когда перебор завершается, done устанавливается в true.

Теперь, если мы выполним цикл for...of или используем оператор spread (...), то мы получим доступ к элементам объекта myIterable.

# 2. Типы данных и выражения ECMAScript
## 1) Вычисляемые свойства объекта 
Вычисляемые свойства объекта (Computed properties) - это особый способ определения свойств объекта, который позволяет использовать выражения в качестве имен свойств. Это позволяет динамически определять свойства объекта на основе вычислений во время выполнения программы.

Давайте рассмотрим пример:
```
const dynamicKey = "age";
const person = {
  name: "John",
  [dynamicKey]: 30, // Вычисляемое свойство
};

console.log(person.name); // Вывод: John
console.log(person.age);  // Вывод: 30
```
В этом примере свойство age объекта person вычисляется динамически с использованием переменной dynamicKey. Таким образом, вы можете создавать свойства, чьи имена определяются в зависимости от контекста или вычислений.

Это может быть полезно, например, когда вы хотите динамически создавать свойства объекта на основе данных или условий в вашей программе.

## 2) Перебор ключей объекта 
Перебор (или итерация) ключей объекта в JavaScript можно осуществить с использованием различных методов. 

Вот несколько способов:
#### 1. Цикл for...in:
   
Цикл for...in позволяет перебрать все перечисляемые свойства объекта, включая его прототип. Обычно используется для перебора ключей объекта.
```
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key); // Выводит: a, b, c
}
```
#### 2. Метод Object.keys():
   
Метод Object.keys() возвращает массив, содержащий все собственные перечисляемые ключи объекта.
```
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // Выводит: ["a", "b", "c"]
```
#### 3. Метод Object.getOwnPropertyNames():
   
Метод Object.getOwnPropertyNames() возвращает массив, содержащий все собственные ключи (включая неперечисляемые) объекта.
```
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.getOwnPropertyNames(obj);
console.log(keys); // Выводит: ["a", "b", "c"]
```
#### 4. Метод Object.getOwnPropertySymbols():
   
Метод Object.getOwnPropertySymbols() возвращает массив всех символьных ключей объекта.
```
const key1 = Symbol("key1");
const key2 = Symbol("key2");
const obj = { [key1]: 1, [key2]: 2 };
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // Выводит массив символьных ключей
```

# 3. Функциональная область

### 1) Глобальная и функциональная области 
#### Глобальная область видимости:
Глобальная область видимости охватывает весь код, который находится за пределами всех функций. Переменные и функции, объявленные в глобальной области видимости, могут быть доступны и использованы в любой части кода.

Пример:
```
const globalVariable = 42;

function globalFunction() {
  console.log(globalVariable);
}

globalFunction(); // Выводит: 42
```
#### Функциональная область видимости:
Функциональная область видимости связана с областью видимости функций. Переменные и функции, объявленные внутри функции, являются локальными для этой функции и не видны за её пределами. Они существуют только внутри своей функции.

Пример:
```
function outerFunction() {
  const outerVariable = "Hello";

  function innerFunction() {
    console.log(outerVariable);
  }

  innerFunction(); // Выводит: Hello
}

outerFunction();
```

### 2) Области видимости переменных 
Основные типы областей видимости:
#### Глобальная область видимости (Global Scope):
Переменные, объявленные вне всех функций, имеют глобальную область видимости. Они могут быть доступны и использованы в любой части кода, включая внутри функций.

Пример:
```
const globalVariable = "I am global";

function someFunction() {
  console.log(globalVariable);
}

someFunction(); // Вывод: I am global
```
#### Функциональная область видимости функции (Function Scope):
Переменные, объявленные внутри функции, имеют функциональная область видимости. Они могут быть использованы только внутри этой функции и не видны за её пределами.

Пример:
```
function myFunction() {
  const localVariable = "I am local";
  console.log(localVariable);
}

myFunction(); // Вывод: I am local
// console.log(localVariable); // Ошибка - переменная не определена
```
#### Блочная область видимости (Block Scope):
Переменные, объявленные с использованием let или const внутри блока кода (например, внутри цикла или условия), имеют блочную область видимости. Они ограничены только этим блоком и не видны за его пределами.

Пример:
```
if (true) {
  let blockVariable = "I am inside a block";
  console.log(blockVariable);
}

// console.log(blockVariable); // Ошибка - переменная не определена
```
#### Область видимости функции с замыканием (Closure Scope):
Функции в JavaScript создают области видимости, и когда функция объявлена внутри другой функции, она может сохранить доступ к переменным своей внешней функции после завершения её выполнения. Это называется замыканием.

Пример:
```
function outerFunction() {
  const outerVariable = "I am outer";

  function innerFunction() {
    console.log(outerVariable);
  }

  return innerFunction;
}

const closure = outerFunction();
closure(); // Вывод: I am outer
```
Корректное управление областями видимости помогает избегать конфликтов имён и обеспечивает правильное взаимодействие между частями кода.

Важно понимать, что переменные, объявленные с использованием ключевого слова var, имеют функциональную область видимости. 
Переменные, объявленные с использованием let и const, имеют блочную область видимости, что означает, что они ограничены только блоком кода 
(например, внутри цикла или условия).

Области видимости влияют на то, какие переменные и функции видны в определенных частях кода, и это важно для управления и избегания конфликтов имён переменных.

### 3) Вложенные области 
Вложенные области видимости - это ситуация, когда одна область видимости находится внутри другой. В JavaScript это означает, что одна функция определена внутри другой, и внутренняя функция имеет доступ к переменным и параметрам внешней функции.

Вложенные области видимости позволяют создавать замыкания, которые позволяют сохранять доступ к переменным и состоянию внешней функции даже после завершения её выполнения. Это чрезвычайно полезный механизм в JavaScript, который используется для создания функций с замыканиями.

Пример вложенных областей видимости с замыканием:
```
function outerFunction() {
  const outerVariable = "I am outer";

  function innerFunction() {
    console.log(outerVariable); // innerFunction имеет доступ к outerVariable
  }

  return innerFunction;
}

const closure = outerFunction();
closure(); // Вывод: I am outer
```
В этом примере функция innerFunction определена внутри функции outerFunction, и она имеет доступ к переменной outerVariable, которая определена во внешней функции. 
Когда мы вызываем outerFunction() и сохраняем результат в closure, мы создаем замыкание, которое запоминает состояние outerVariable даже после завершения выполнения outerFunction.
Вложенные области видимости и замыкания часто используются для создания функций с частично заданными аргументами, асинхронных операций и других паттернов программирования.

# 4. Параметры / аргументы функций
Примитивные значения всегда передаются по значению, а объекты передаются по ссылке. 
### 1) Параметры функций 
Параметры функции определяются в её определении в круглых скобках. Параметры - это переменные, которые функция принимает как входные данные. 
Когда функция вызывается, значения переданных аргументов присваиваются этим параметрам.
Пример определения параметров функции:
```
function greet(name, age) {
  console.log(`Hello, ${name}! You are ${age} years old.`);
}

greet("Alice", 25); // Вывод: Hello, Alice! You are 25 years old.
```
В этом примере name и age - это параметры функции greet. При вызове функции greet("Alice", 25) значения "Alice" и 25 передаются 
в функцию и присваиваются соответствующим параметрам.
Если вы передадите больше аргументов, чем определено параметров, дополнительные аргументы будут проигнорированы. 
Если передано меньше аргументов, чем параметров, недостающие параметры будут иметь значение undefined.
### 2) разница между параметрами, передаваемыми по значению и по ссылке
#### Параметры, передаваемые по значению:
Когда вы передаете примитивное значение (такое как число, строка, булево значение) в функцию, это значение копируется и передается в функцию. Внутри функции вы работаете с копией, и изменения внутри функции не влияют на оригинальное значение вне функции.

Пример: 
```
function modifyValue(value) {
  value = 10; // Изменение копии
  console.log(value); // Вывод: 10
}

let number = 5;
modifyValue(number);
console.log(number); // Вывод: 5 (оригинальное значение не изменилось)
```
#### Параметры, передаваемые по ссылке:
Когда вы передаете объект (включая массивы и функции) в функцию, передается не сам объект, а ссылка на объект. 
Это означает, что внутри функции вы работаете с тем же объектом, и любые изменения, сделанные внутри функции, будут отражены на оригинальном объекте.

Пример: 
```
function modifyArray(arr) {
  arr.push(4); // Изменение оригинального массива
  console.log(arr); // Вывод: [1, 2, 3, 4]
}

let myArray = [1, 2, 3];
modifyArray(myArray);
console.log(myArray); // Вывод: [1, 2, 3, 4] (оригинальный массив изменился)
```
### 3) Как обрабатывать динамическое количество функциональных параметров ? 
Обрабатывать динамическое количество функциональных параметров с использованием объекта arguments, оператора rest или функции ...args.

#### Объект arguments:
Когда функция вызывается, она имеет доступ к объекту arguments, который содержит список всех переданных аргументов в виде псевдомассива. 
Вы можете перебрать arguments в цикле или получить доступ к определенным аргументам по индексу.

Пример: 
```
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3, 4)); // Вывод: 10
```
#### Оператор rest:
Оператор rest (...) позволяет собирать оставшиеся аргументы функции в массив. 
Это позволяет более явно работать с динамическим количеством аргументов.

Пример: 
```
function sum(...numbers) {
  let total = 0;
  for (let number of numbers) {
    total += number;
  }
  return total;
}

console.log(sum(1, 2, 3, 4)); // Вывод: 10
```
#### Функция ...args:
Если вы используете стрелочные функции или хотите передать аргументы из одной функции в другую, 
вы можете использовать функцию ...args для передачи аргументов.

Пример: 
```
function myFunction(...args) {
  anotherFunction(...args);
}

function anotherFunction(a, b, c) {
  console.log(a, b, c);
}

myFunction(1, 2, 3); // Вывод: 1 2 3
```
Выбор метода зависит от вашей конкретной ситуации и стиля кодирования. 
Оператор rest обычно является более современным и предпочтительным способом для обработки динамического количества параметров.

# 5. Расширенные закрытия 
### Контекст (лексическая среда)
Контекст (или лексическая среда) - это среда, в которой выполняется код, и которая определяет доступные переменные, функции и другие ресурсы, а также способ, которым код взаимодействует с этими ресурсами. Контекст влияет на область видимости и доступность переменных, а также на то, как функции и выражения интерпретируются и выполняются.
Каждый раз, когда функция вызывается, создается новая лексическая среда, которая содержит локальные переменные и параметры функции, а также ссылки на внешние среды, образующие цепочку областей видимости. Эта цепочка называется "цепочкой областей видимости" или "цепочкой областей лексической среды".

Пример: 
```
function outerFunction() {
  const outerVariable = "I am from outer";

  function innerFunction() {
    console.log(outerVariable); // innerFunction имеет доступ к outerVariable
  }

  return innerFunction;
}

const closure = outerFunction();
closure(); // Вывод: I am from outer
```
В этом примере у функции innerFunction есть доступ к переменной outerVariable, определенной во внешней функции outerFunction. Это возможно благодаря цепочке областей лексической среды, которая позволяет функциям сохранять доступ к переменным в их родительских средах, даже после завершения выполнения этих родительских функций.

Контекст также связан с ключевым словом this, которое определяет, как функция взаимодействует с объектом, из которого она была вызвана. Значение this определяется на момент вызова функции и зависит от контекста вызова.

### Контекста создания функций (лексическая среда)
Контекст создания функций (также известный как лексическая среда создания или лексическое окружение) - это среда, в которой определена функция в момент её создания. 
Это важное понятие связано с тем, как функции сохраняют информацию о своей лексической среде даже после завершения выполнения этой среды.

Когда вы создаете функцию внутри другой функции, вложенная функция запоминает ссылку на лексическую среду (контекст создания), в которой она была создана. 
Это позволяет вложенным функциям сохранять доступ к переменным и параметрам внешней функции даже после того, как внешняя функция завершила выполнение.

Пример:
```
function outerFunction() {
  const outerVariable = "I am from outer";

  function innerFunction() {
    console.log(outerVariable); // innerFunction имеет доступ к outerVariable
  }

  return innerFunction;
}

const closure = outerFunction(); // closure хранит ссылку на лексическую среду outerFunction

closure(); // Вывод: I am from outer
```
В этом примере, когда функция innerFunction создается внутри outerFunction, она запоминает ссылку на лексическую среду outerFunction, включая переменную outerVariable. Даже после того, как outerFunction завершает выполнение и её лексическая среда уходит в память, innerFunction сохраняет доступ к outerVariable благодаря контексту создания.

### Разница между областью и контекстом
#### Область (Scope):
Определяет, где переменные доступны и могут быть использованы. В JavaScript существует глобальная область и локальные области видимости функций или блоков кода.

Пример: 
```
const globalVariable = "I am global"; // Глобальный объем

function myFunction() {
  const localVariable = "I am local"; // Локальный объем
}
```
Переменные, объявленные в глобальной области, видны везде, а переменные внутри локальной области видимости доступны только внутри соответствующих функций или блоков.
#### Контекст (Context):
Контекст - это то, что определяет, как функция взаимодействует с объектом, из которого она была вызвана. 
В контексте функции ключевое слово this указывает на объект, с которым она связана. Контекст зависит от того, как функция была вызвана.

Пример:
```
const obj = {
  name: "John",
  greet: function() {
    console.log(`Hello, ${this.name}!`);
  }
};

obj.greet(); // Вывод: Hello, John!
```
В этом примере this внутри метода greet ссылается на объект obj, потому что метод был вызван с контекстом объекта obj.
Таким образом, "объем" относится к доступности переменных в разных частях кода (глобально или локально), 
а "контекст" определяет, как функция взаимодействует с объектом, из которого она была вызвана, с помощью ключевого слова this.
### Внутренняя/внешняя лексическая среда
Внутренняя и внешняя лексическая среда связаны с тем, как функции в JavaScript могут сохранять доступ к переменным 
и параметрам из своего окружения даже после завершения выполнения этого окружения.
#### Внешняя лексическая среда (Outer Lexical Environment):
Это среда, в которой функция была определена (создана), независимо от места её вызова. 
Внешняя лексическая среда содержит информацию о переменных и параметрах, доступных во время определения функции.

Пример:
```
function outerFunction() {
  const outerVariable = "I am from outer";

  function innerFunction() {
    console.log(outerVariable); // Внутренняя функция имеет доступ к внешней переменной
  }

  return innerFunction;
}

const closure = outerFunction();
closure();
```
В этом примере внешняя лексическая среда для innerFunction - это лексическая среда outerFunction, потому что innerFunction определена внутри outerFunction.
#### Внутренняя лексическая среда (Inner Lexical Environment):
Это среда, создаваемая при вызове функции, в которой функция выполняется. 
Внутренняя лексическая среда содержит локальные переменные функции, параметры, а также ссылку на внешнюю лексическую среду, 
образуя цепочку областей видимости (Scope Chain).

Пример:
```
function outerFunction() {
  const outerVariable = "I am from outer";

  function innerFunction() {
    const innerVariable = "I am from inner";
    console.log(outerVariable); // Внутренняя функция может видеть внешние переменные
  }

  return innerFunction;
}

const closure = outerFunction();
closure();
```
В этом примере внутренняя лексическая среда для innerFunction - это среда, созданная при вызове innerFunction. 
Она имеет доступ к локальным переменным innerFunction и к переменным внешней лексической среды outerFunction.

### Механизм обхода лексической среды
Механизм обхода лексической среды связан с тем, как функции сохраняют доступ к переменным и параметрам из своей внешней среды даже после завершения выполнения этой среды. Этот механизм называется замыканием (closures).

При создании функции внутри другой функции (внутренней функции) сохраняется ссылка на лексическую среду (контекст создания) этой внешней функции. Это позволяет внутренней функции сохранять доступ к переменным и параметрам внешней функции даже после завершения выполнения внешней функции.

Пример:
```
function outerFunction() {
  const outerVariable = "I am from outer";

  function innerFunction() {
    console.log(outerVariable); // innerFunction сохраняет доступ к outerVariable
  }

  return innerFunction;
}

const closure = outerFunction(); // Здесь создается замыкание
closure(); // Вывод: I am from outer
```
В этом примере функция closure представляет собой внутреннюю функцию innerFunction, которая была создана внутри outerFunction. Когда outerFunction вызывается и возвращает innerFunction, замыкание сохраняет ссылку на лексическую среду outerFunction, включая переменную outerVariable. Даже после завершения выполнения outerFunction, closure все равно имеет доступ к outerVariable благодаря механизму замыкания.
### Cвязи между функцией и лексической средой
Связь между функцией и лексической средой в JavaScript очень важна и определяет, как функции сохраняют доступ к переменным и параметрам во время своего создания и выполнения. Вот как это работает:

#### Создание функции:
Когда вы создаете функцию, она "запоминает" (сохраняет ссылку на) свою лексическую среду (контекст создания), то есть среду, в которой она была определена. Это включает в себя все локальные переменные, параметры и другие ресурсы, доступные в этой среде.
#### Вызов функции:
Когда функция вызывается, создается новая внутренняя лексическая среда (контекст выполнения), в которой она будет выполняться. Эта внутренняя среда содержит локальные переменные функции, параметры, а также ссылку на внешнюю лексическую среду (среду, в которой функция была определена), образуя цепочку областей видимости (Scope Chain).
#### Замыкание (Closures):
Замыкание - это результат связи между функцией и её лексической средой создания. Функция сохраняет доступ к переменным и ресурсам этой среды даже после того, как она завершила выполнение. Это позволяет функциям создавать замыкания, которые сохраняют состояние и могут использовать данные из внешней лексической среды.

Пример:
```
function outerFunction() {
  const outerVariable = "I am from outer"; // Лексическая среда создания для outerFunction

  function innerFunction() {
    console.log(outerVariable); // Связь между функцией и внешней лексической средой (замыкание)
  }

  return innerFunction;
}

const closure = outerFunction(); // Создание замыкания
closure(); // Вывод: I am from outer
```
В этом примере innerFunction создает замыкание, которое "запоминает" лексическую среду outerFunction, включая переменную outerVariable. 
Это позволяет innerFunction сохранить доступ к outerVariable даже после завершения выполнения outerFunction.

Таким образом, связь между функцией и лексической средой определяет механизм замыкания, который является важным понятием для понимания работы функций в JavaScript.

# 6. ECMAScript Промежуточный
### Параметры функции по умолчанию
Параметры по умолчанию позволяют задавать формальным параметрам функции значения по умолчанию в случае, 
если функция вызвана без аргументов, или если параметру явным образом передано значение undefined.

Пример:
```
function greet(name = "Guest") {
  console.log(`Hello, ${name}!`);
}

greet();         // Вывод: Hello, Guest! (параметр name не передан, используется значение по умолчанию)
greet("Alice");  // Вывод: Hello, Alice! (параметр name передан)
```
### Как использовать оператор spread для аргументов Function ?
Оператор расширения (spread operator) в JavaScript позволяет передавать элементы массива или свойства объекта как аргументы в функцию. 
Это полезно, когда у вас есть массив данных, которые вы хотите передать функции как отдельные аргументы.

Пример использования оператора spread для аргументов функции:
```
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];

const result = sum(...numbers); // Расширение массива numbers как аргументов функции
console.log(result); // Вывод: 6
```
В этом примере оператор ...numbers разбивает массив numbers на его элементы, которые затем передаются функции sum как отдельные аргументы

### Как сравнивать аргументы и остальные параметры ?
Для сравнения аргументов и остальных параметров в функции вам нужно использовать операторы сравнения (===, !==, <, >, <=, >= и т. д.), 
так же как вы сравнивали бы любые другие значения в JavaScript.
```
function compareArgsAndParams(a, b, ...restParams) {
  console.log(`a: ${a}`);
  console.log(`b: ${b}`);
  console.log(`restParams: ${restParams}`);
  
  if (a === b) {
    console.log("a and b are equal");
  } else {
    console.log("a and b are not equal");
  }

  if (restParams.length === 0) {
    console.log("No additional parameters");
  } else {
    console.log(`Additional parameters: ${restParams}`);
  }
}

compareArgsAndParams(5, 5, 10, 20, 30);
```
В этом примере функция compareArgsAndParams принимает два аргумента a и b, а также остальные параметры restParams (все параметры, которые идут после b). 
Затем она сравнивает a и b и выводит соответствующие сообщения. Также она проверяет наличие остальных параметров (restParams) и выводит информацию об этом.

### Оператор spread для массива
Оператор расширения (spread operator) для массива в JavaScript позволяет разбить массив на его элементы и использовать эти элементы в другом массиве, вызове функции, объекте или в другом контексте, где ожидается несколько аргументов или элементов.

Пример использования оператора spread для массива:
#### Копирование массива:
```
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];

console.log(copiedArray); // Вывод: [1, 2, 3]
```
### Использование оператора spread для конкатенации массива
Оператор расширения (spread operator) можно использовать для конкатенации (объединения) массивов. 
Он позволяет разбить массив на его элементы и добавить их к другому массиву. Вот как это делается:

Пример: 
```
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const concatenatedArray = [...array1, ...array2];

console.log(concatenatedArray); // Вывод: [1, 2, 3, 4, 5, 6]
```
Если вы хотите конкатенировать только два массива, вы можете использовать более старый метод concat():
Пример: 
```
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const concatenatedArray = array1.concat(array2);

console.log(concatenatedArray); // Вывод: [1, 2, 3, 4, 5, 6]
```
### Деструктурирующее назначение
Деструктурирующее назначение позволяет удобно извлекать и использовать данные из структур данных, сэкономив время и упростив код. 
Это особенно полезно при работе с большими объектами или массивами, когда вы хотите извлечь только определенные значения.
#### Деструктурирующее назначение массивов:

Пример: 
```
const numbers = [1, 2, 3];

const [a, b, c] = numbers;

console.log(a); // Вывод: 1
console.log(b); // Вывод: 2
console.log(c); // Вывод: 3
```
#### Деструктурирующее назначение объектов:

Пример: 
```
const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
};

const { firstName, lastName, age } = person;

console.log(firstName); // Вывод: John
console.log(lastName);  // Вывод: Doe
console.log(age);       // Вывод: 30
```
### Цикл for..of(optional)
Цикл for...of предоставляет способ перебора элементов коллекций (например, массивов, строк, наборов Set, итерируемых объектов) 
без необходимости следить за индексами или индексированными свойствами. Он выполняет итерацию по значениям коллекции, а не по их индексам.
Цикл работает только с итерируемыми объектами.
```
for (variable of iterable) {
  // код для выполнения на каждой итерации
}
```
variable: Переменная, в которую будет присваиваться текущее значение элемента коллекции на каждой итерации.
iterable: Итерируемая коллекция, которую вы хотите перебрать.
#### Перебор элементов массива:
```
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

# 7. Модули в JavaScript 
### Что такое модуль / модуль pattern? Для каких целей они были созданы?
Модуль (Module) или модульный паттерн (Module Pattern) - это подход к организации и структурированию кода в программировании. Модули позволяют разделять код на небольшие, независимые, самодостаточные компоненты, которые можно использовать повторно и поддерживать с минимальными затратами.

Цели создания модульного паттерна:

Изоляция и инкапсуляция: Модули позволяют скрывать внутренние детали реализации от внешнего кода, что способствует более чистому и безопасному разделению обязанностей в приложении. Это помогает избежать нежелательных взаимодействий и конфликтов между разными частями кода.
Повторное использование кода: Когда функциональность упакована в модуль, его можно легко повторно использовать в разных частях проекта или даже в разных проектах. Это способствует экономии времени и уменьшению дублирования кода.
Управление зависимостями: Модули позволяют явно определить зависимости между компонентами, что делает более прозрачным и управляемым управление зависимостями между разными частями приложения.
Улучшение сопровождаемости: Разделение кода на модули упрощает обслуживание, отладку и тестирование, так как разные части приложения могут быть анализированы и изменены независимо друг от друга.
### Типы модулей (AMD, ES6, CommonJS, UMD)
#### Revealing Module Pattern: 
Паттерн, который использует замыкания для скрытия некоторых свойств и методов, раскрывая только те, которые должны быть видны снаружи модуля.
#### CommonJS и ES6 Modules: 
Стандарты для модульной системы в JavaScript. CommonJS применяется в среде сервера (например, Node.js), а ES6 Modules - в современных браузерах. Они позволяют явно экспортировать и импортировать функции, классы, переменные и другие элементы из модулей.
#### AMD (Asynchronous Module Definition): 
Подход к модульности, который позволяет загружать модули асинхронно, что полезно в браузерном окружении.
#### UMD (Universal Module Definition): 
Шаблон, который позволяет создавать модули, совместимые и с CommonJS, и с AMD, и с глобальными переменными.
### Синтаксис модулей
Синтаксис модулей может варьироваться в зависимости от используемой версии JavaScript и используемой модульной системы. Вот примеры основных синтаксических конструкций для работы с модулями:
#### ES6 Modules (стандарт ECMAScript 2015+):
Экспорт:
```
// Модуль foo.js
export const foo = "Hello from foo!";
```
Импорт:
```
// Другой модуль
import { foo } from "./foo.js";
console.log(foo); // Вывод: Hello from foo!
```
#### CommonJS (в Node.js и некоторых инструментах сборки на стороне сервера):
Экспорт:
```
// Модуль foo.js
exports.foo = "Hello from foo!";
```

Импорт:
```
// Другой модуль
const { foo } = require("./foo.js");
console.log(foo); // Вывод: Hello from foo!
```
### Общие функции модулей (экспорт по умолчанию, именованный экспорт, экспорт как и т.д.)
#### Экспорт по умолчанию (Default Export):
С помощью экспорта по умолчанию вы можете экспортировать одно значение, которое будет считаться "основным" значением модуля.
Экспорт:
```
// Модуль foo.js
export default function sayHello() {
  console.log("Hello!");
}
```
Импорт:
```
// Другой модуль
import sayHello from "./foo.js";
sayHello(); // Вывод: Hello!
```
#### Именованный экспорт (Named Export):
Вы можете экспортировать несколько значений из модуля с помощью именованных экспортов.
Экспорт: 
```
// Модуль foo.js
export function sayHello() {
  console.log("Hello!");
}

export function sayGoodbye() {
  console.log("Goodbye!");
}
```

Импорт: 
```
// Другой модуль
import { sayHello, sayGoodbye } from "./foo.js";
sayHello(); // Вывод: Hello!
sayGoodbye(); // Вывод: Goodbye!
```
#### Именованный экспорт с переименованием (Renamed Named Export):
Можно также переименовать импортируемые значения для более локаничного использования.
Импорт с переименованием:
```
// Другой модуль
import { sayHello as hello, sayGoodbye as goodbye } from "./foo.js";
hello(); // Вывод: Hello!
goodbye(); // Вывод: Goodbye!
```
#### Экспорт как (Export As):
Этот синтаксис позволяет сгруппировать несколько значений в один объект при экспорте и затем импортировать их сразу.
Экспорт как: 
```
// Модуль foo.js
const message1 = "Hello";
const message2 = "Goodbye";

export { message1, message2 };
```
Импорт: 
```
// Другой модуль
import * as messages from "./foo.js";
console.log(messages.message1); // Вывод: Hello
console.log(messages.message2); // Вывод: Goodbye
```
### Динамический импорт
Динамический импорт в JavaScript - это механизм, который позволяет загружать модули асинхронно по требованию, во время выполнения программы. 
Это особенно полезно, когда вам нужно загрузить модуль только в определенный момент времени, например, при выполнении определенного действия пользователя или в зависимости от условий.

Синтаксис динамического импорта выглядит так:
```
import(modulePath)
  .then((module) => {
    // Здесь можно использовать экспортированные значения из модуля
  })
  .catch((error) => {
    // Обработка ошибки загрузки модуля
  });
```

# 8. Продвинутая функция 
### this в функции 
this используется для обращения к текущему объекту или контексту выполнения внутри функции. Значение this может меняться в зависимости от контекста вызова функции. Вот некоторые распространенные сценарии использования this в функциях:
#### Контекст объекта:
В методах объекта this ссылается на сам объект, в котором определен метод.

Пример:
```
const person = {
  firstName: 'John',
  sayHello: function() {
    console.log(`Hello, my name is ${this.firstName}`);
  }
};

person.sayHello(); // Вывод: Hello, my name is John
```
#### Функции-конструкторы:
Внутри функции-конструктора this ссылается на новый экземпляр объекта, который будет создан при вызове функции с оператором new.

Пример: 
```
function Car(make, model) {
  this.make = make;
  this.model = model;
}

const myCar = new Car('Toyota', 'Camry');
console.log(myCar.make); // Вывод: Toyota
```
### Ссылочный тип и его потеря 
Ссылочные типы в JavaScript включают объекты, массивы, функции и другие структуры данных, которые хранятся в памяти и передаются по ссылке. 
Когда переменная содержит ссылку на объект, она фактически указывает на место в памяти, где хранятся данные объекта.

Пример:
```
const obj1 = { name: 'Alice' };
const obj2 = obj1; // obj2 ссылается на тот же объект, что и obj1

obj2.name = 'Bob';

console.log(obj1.name); // Вывод: Bob
```
Потеря ссылки на объект происходит, когда переменная, которая хранила ссылку на объект, теряет эту ссылку. Это может произойти, например, при присваивании нового значения переменной или при передаче значения в функцию.

 Пример: 
```
function modifyObject(obj) {
  obj = { name: 'Charlie' }; // Переменная obj теперь ссылается на новый объект
}

const person = { name: 'Alice' };

modifyObject(person);

console.log(person.name); // Вывод: Alice
```
### Разница между функцией и методом
Разница между функцией и методом сводится к контексту и способу вызова:

* Функция может вызываться независимо от объекта и контекста.
* Метод связан с объектом и вызывается на нем через точечную нотацию, обычно оперируя данными объекта.

Функция - это блок кода, который выполняет определенную операцию или действие. Она может быть вызвана в любой части программы, независимо от контекста, в котором она была определена. Функции могут принимать аргументы (входные данные), обрабатывать их и возвращать результат. Функции могут быть объявлены глобально или внутри других функций, блоков кода или объектов.

Пример: 
```
function add(a, b) {
  return a + b;
}

const result = add(3, 5); // Вызов функции
console.log(result); // Вывод: 8
```
Метод - это функция, которая связана с объектом и действует на нем. Он вызывается через точечную нотацию, предоставляя объект, на котором он вызывается, как контекст выполнения. Методы обычно выполняют операции над данными объекта и часто используют свойства объекта внутри себя.

Пример: 
```
const person = {
  firstName: 'John',
  lastName: 'Doe',
  fullName: function() {
    return this.firstName + ' ' + this.lastName;
  }
};

console.log(person.fullName()); // Вызов метода
```
### Как работает this и какие могут возникать проблемы ?
#### Как работает this:
Значение this может быть определено следующим образом:

Глобальный контекст: В глобальном контексте (вне функций или методов), this обычно ссылается на глобальный объект (например, window в браузере).

Метод объекта: Внутри методов объекта, this ссылается на сам объект, в котором определен метод.

Функция-конструктор: Внутри функции-конструктора, this ссылается на новый экземпляр объекта, который будет создан при вызове функции с оператором new.

Анонимные функции: В анонимных функциях, значение this может зависеть от контекста, в котором функция вызывается. Если она вызывается в глобальной области видимости, this будет ссылаться на глобальный объект.

Arrow-функции: В arrow-функциях this берется из окружающего лексического контекста, что отличает их от обычных функций.
#### Проблемы с this:
Проблема потери контекста (this): 
Одним из распространенных примеров проблемы с this является потеря контекста при передаче методов как колбэков. В таких случаях значение this может потерять свой ожидаемый контекст и ссылаться на неожиданный объект или даже быть undefined.

Методы объекта внутри вложенных функций: 
Вложенные функции внутри метода объекта могут иметь свой собственный контекст выполнения, что может привести к неправильному значению this внутри этих функций.

Использование в асинхронных операциях: 
В асинхронных операциях, таких как колбэки, Promise или async/await, значение this может меняться в зависимости от контекста вызова и времени выполнения.
### Способы заменить this
Чтобы избежать проблем с this, можно использовать стрелочные функции, явно привязывать контекст с помощью методов bind, call или apply, 
или сохранять значение this во временной переменной перед вложенными вызовами функций.
### Уметь использовать встроенные методы вызова и применения функций
1. call() и apply(): Эти методы позволяют вызвать функцию с определенным значением this и аргументами. Разница между ними заключается в способе передачи аргументов - через список аргументов для call() и через массив аргументов для apply().
   
Пример:
```
function greet(message) {
  console.log(`${message}, ${this.name}!`);
}

const person = { name: 'Alice' };

greet.call(person, 'Hello'); // Вывод: Hello, Alice!
greet.apply(person, ['Hi']); // Вывод: Hi, Alice!
```
2. bind(): Метод bind() создает новую функцию с определенным значением this, которая может быть вызвана позже.

Пример: 
```
const greetPerson = greet.bind(person);
greetPerson('Hey'); // Вывод: Hey, Alice!
```
3. bind() для передачи параметров: bind() также может использоваться для привязки аргументов, не изменяя контекст this.

Пример:
```
function multiply(a, b) {
  return a * b;
}

const multiplyByTwo = multiply.bind(null, 2);
console.log(multiplyByTwo(5)); // Вывод: 10
```
4. call() и apply() для функций массивов: Эти методы часто используются с функциями массивов, чтобы применить функцию к элементам массива.

Пример:
```
const numbers = [1, 2, 3, 4];
const sum = Array.prototype.reduce.call(numbers, (total, num) => total + num, 0);
console.log(sum); // Вывод: 10
```
5. forEach(): Метод forEach() позволяет выполнить функцию для каждого элемента массива.

Пример: 
```
const names = ['Alice', 'Bob', 'Charlie'];
names.forEach((name, index) => {
  console.log(`${index + 1}: ${name}`);
});
```
6. map(): Метод map() создает новый массив, применяя функцию к каждому элементу исходного массива.

Пример: 
```
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Вывод: [2, 4, 6]
```
### Как привязать this область к функции
1. Использование метода bind()
2. Использование стрелочных функций (Arrow Functions)
3. Использование функции обратного вызова
4. Использование стрелочных функций для обработчиков событий
### Привязка, привязка одной функции дважды
Привязка функции может быть полезным, когда вам необходимо явно указать контекст (this) для вызова функции. 
Однако привязка одной функции дважды может привести к некоторым особенностям и не всегда является хорошей практикой. 

Пример: 
```
function greet(message) {
  console.log(`${message}, ${this.name}!`);
}

const person1 = { name: 'Alice' };
const person2 = { name: 'Bob' };

const greetPerson1 = greet.bind(person1);
const greetPerson2 = greet.bind(person2);

greetPerson1('Hello'); // Вывод: Hello, Alice!
greetPerson2('Hi');    // Вывод: Hi, Bob!
```
В этом примере мы создали две новые функции (greetPerson1 и greetPerson2), каждая из которых связана с разным объектом.
При вызове этих функций, this будет ссылаться на соответствующий объект.

# 9. Функциональные паттерны
### Callback (функция в качестве аргумента)
Callback (колбэк) в программировании - это функция, которая передается в другую функцию в качестве аргумента и 
выполняется после завершения выполнения основной функции. Колбэки часто используются для обработки асинхронных операций, 
событий или для разделения кода на более мелкие и переиспользуемые блоки.

Пример использования колбэка:
```
function fetchData(url, callback) {
  // Симулируем асинхронный запрос данных
  setTimeout(function() {
    const data = { id: 1, name: 'Alice' };
    callback(data); // Вызов колбэка после получения данных
  }, 1000);
}

function processData(data) {
  console.log(`Received data: ${JSON.stringify(data)}`);
}

fetchData('https://api.example.com/data', processData);
```
### Callback паттерн
Callback-паттерн (или паттерн обратного вызова) - это концепция в программировании, при которой функция передается в качестве аргумента другой функции 
и выполняется после завершения выполнения этой основной функции. Этот паттерн широко используется для работы с асинхронным кодом и управления потоком выполнения.

Основные характеристики callback-паттерна:
Передача функции: Функция (колбэк) передается в качестве аргумента другой функции.
Выполнение после завершения: Колбэк вызывается только после завершения выполнения основной функции или какого-либо события.

Пример использования callback-паттерна:
```
function fetchData(url, callback) {
  // Симулируем асинхронный запрос данных
  setTimeout(function() {
    const data = { id: 1, name: 'Alice' };
    callback(data); // Вызов колбэка после получения данных
  }, 1000);
}

function processData(data) {
  console.log(`Received data: ${JSON.stringify(data)}`);
}

fetchData('https://api.example.com/data', processData);
```
В этом примере fetchData принимает URL и колбэк processData. Она выполняет асинхронную операцию (задержку через setTimeout) 
и затем вызывает переданный колбэк, передавая в него полученные данные.
### IIFE паттерн
IIFE (Immediately Invoked Function Expression) - это паттерн в JavaScript, который представляет собой функцию, объявленную и вызванную немедленно после ее определения. IIFE позволяет создать локальную область видимости для переменных, изолировав их от глобальной области видимости, и выполнить код сразу же. Этот паттерн часто используется для создания модульных компонентов, избегая конфликтов имён и загрязнения глобальной области видимости.

Синтаксис IIFE выглядит так:
```
(function() {
  // код, который будет выполнен
})();
```
Пример использования IIFE:
```
(function() {
  var name = 'Alice';
  console.log('Hello, ' + name);
})();

// Переменная name недоступна вне IIFE
//console.log(name); // Ошибка: name is not defined
```
В данном примере, код внутри IIFE выполняется немедленно, и переменная name остается локальной для этой области видимости. 
Поэтому попытка доступа к переменной name вне IIFE вызовет ошибку.
### Ограничения Callback (ад Callback)
Callback Hell (Ад колбэков): Это ситуация, когда вложенность колбэков становится слишком глубокой и код становится сложночитаемым и трудноподдерживаемым. 
Это может произойти, когда множество асинхронных операций зависит друг от друга.
### Каррирование и частичные функции
Каррирование - это процесс преобразования функции с несколькими аргументами в последовательность функций с одним аргументом. 
Каждая новая функция принимает один аргумент и возвращает другую функцию, которая также может принимать один аргумент и так далее. 
Это позволяет создавать более специализированные функции и легко комбинировать их.

Пример каррирования: 
```
function add(x) {
  return function(y) {
    return x + y;
  }
}

const add5 = add(5);
console.log(add5(3)); // Вывод: 8
```
В этом примере функция add каррирована, и мы можем создать новую функцию add5, которая всегда будет добавлять 5 к переданному аргументу.

Частичное применение функций - это процесс создания новой функции, фиксируя некоторые из аргументов оригинальной функции. 
Это позволяет создать функцию с "предустановленными" аргументами, что может быть полезно для создания более обобщенных функций.

Пример частичного применения: 
```
function multiply(a, b, c) {
  return a * b * c;
}

const double = multiply.bind(null, 2);
const triple = multiply.bind(null, 3);

console.log(double(4, 5)); // Вывод: 40 (2 * 4 * 5)
console.log(triple(4, 5)); // Вывод: 60 (3 * 4 * 5)
```
В этом примере функция multiply частично применяется с помощью метода bind(), фиксируя первый аргумент.

# 10. Объектно-ориентированное программирование
### new ключевое слово
Ключевое слово new используется для создания новых экземпляров объектов на основе функций-конструкторов или классов.
### как ключевое слово new работает ?
Рассмотрим, как работает ключевое слово new в контексте функций-конструкторов:

Когда вы используете new перед вызовом функции-конструктора, JavaScript выполняет следующие действия:
Создается новый пустой объект.
Свежесозданный объект становится значением this внутри функции-конструктора. Это означает, что все свойства и методы, добавленные к this внутри функции-конструктора, будут относиться к этому новому объекту.
Функция-конструктор выполняется. Внутри функции вы можете добавить свойства и методы к this.
Если функция-конструктор явно не возвращает другой объект (например, объект, созданный с помощью литерала), то возвращается новый объект, созданный на первом шаге.

Пример использования new с функцией-конструктором:
```
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person1 = new Person('Alice', 30);
const person2 = new Person('Bob', 25);

console.log(person1); // { name: 'Alice', age: 30 }
console.log(person2); // { name: 'Bob', age: 25 } 
```
### функциональный конструктор 
Функциональный конструктор (или функция-конструктор) - это способ создания объектов, 
который использует функцию для определения свойств и методов нового экземпляра объекта. Функциональные конструкторы позволяют 
создавать множество объектов с общими характеристиками и поведением.

Пример функционального конструктора:
```
function Person(name, age) {
  this.name = name;
  this.age = age;

  this.sayHello = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  };
}

const person1 = new Person('Alice', 30);
const person2 = new Person('Bob', 25);

person1.sayHello(); // Вывод: Hello, my name is Alice and I am 30 years old.
person2.sayHello(); // Вывод: Hello, my name is Bob and I am 25 years old.
```
В этом примере Person - это функциональный конструктор. Он принимает аргументы name и age, и для каждого созданного экземпляра объекта 
устанавливает свойства name и age. Также, метод sayHello добавляется к каждому экземпляру объекта через this.

Функциональные конструкторы полезны, когда вам нужно создавать множество объектов с общими характеристиками, такими как свойства и методы. Однако они также имеют некоторые ограничения, такие как создание новой копии метода для каждого экземпляра объекта, что может быть неэффективным с точки зрения использования памяти.

### концепция функционального конструктора 
Вот основные шаги и принципы, связанные с концепцией функционального конструктора:

Определение функции-конструктора: Создается функция, которая будет служить функциональным конструктором. 
Внутри этой функции определяются свойства и методы, которые будут общими для всех создаваемых объектов.

Использование ключевого слова this: Внутри функции-конструктора для доступа к свойствам и методам объекта используется ключевое слово this. 
Когда функция-конструктор вызывается с ключевым словом new, this будет указывать на создаваемый экземпляр объекта.

Создание экземпляров объектов: Путем вызова функции-конструктора с ключевым словом new создаются новые объекты, 
которые наследуют свойства и методы из функции-конструктора.
### публичные, частные, статические члены
Публичные члены (Public Members): Публичные члены класса доступны извне и могут быть использованы и изменены другими частями кода. 
Это означает, что они являются частью интерфейса класса, предоставляемого другим объектам.

Пример с публичными членами:
```
class Rectangle {
  constructor(width, height) {
    this.width = width;   // Публичное свойство
    this.height = height; // Публичное свойство
  }

  calculateArea() {
    return this.width * this.height; // Публичный метод
  }
}

const rect = new Rectangle(5, 10);
console.log(rect.calculateArea()); // Вывод: 50
```
Частные члены (Private Members): Частные члены класса не доступны извне и могут быть использованы только внутри самого класса. 
В JavaScript, до появления приватных полей и методов в стандарте (ES6 и выше), существует соглашение использовать символ _ перед именами частных членов, 
чтобы указать их приватный характер, хотя фактически они остаются доступными.

Пример с частными членами (с использованием соглашения):
```
class Rectangle {
  constructor(width, height) {
    this._width = width;   // Частное свойство (соглашение)
    this._height = height; // Частное свойство (соглашение)
  }

  _privateMethod() { // Частный метод (соглашение)
    return this._width * this._height;
  }

  calculateArea() {
    return this._privateMethod(); // Используем частный метод
  }
}

const rect = new Rectangle(5, 10);
console.log(rect.calculateArea()); // Вывод: 50
// console.log(rect._width); // Не рекомендуется обращаться к частным свойствам
```
Статические члены (Static Members): Статические члены принадлежат самому классу, а не экземплярам объектов, 
созданным из этого класса. Они доступны через имя класса и обычно используются для функций или свойств, 
которые относятся к классу в целом, а не к конкретным экземплярам.

Пример со статическими членами:
class MathUtil {
  static PI = 3.14159; // Статическое свойство
  static calculateCircleArea(radius) { // Статический метод
    return this.PI * radius * radius;
  }
}

console.log(MathUtil.calculateCircleArea(5)); // Вывод: 78.53975
### понимать шаблоны и соглашения эмуляции ООП (необязательно)
Понимание шаблонов и соглашений эмуляции объектно-ориентированного программирования (ООП) в JavaScript важно для создания структурированных и понятных программ.
Однако стоит учесть, что JavaScript является прототипно-ориентированным языком, и поддержка ООП в нем реализована с помощью прототипов и конструкторов. 
Вот некоторые шаблоны и соглашения, которые помогут эмулировать ООП в JavaScript:

1. **Функциональные конструкторы и классы:**
   - Используйте функциональные конструкторы или классы для определения типов объектов с общими свойствами и методами.
   - Создавайте экземпляры объектов с помощью ключевого слова `new`.

2. **Прототипы:**
   - Добавляйте методы и свойства, общие для всех экземпляров, в прототип объекта-конструктора.
   - Используйте `Object.prototype` для определения общих методов, доступных всем объектам.

3. **Ключевое слово `this`:**
   - Используйте `this` в методах, чтобы ссылаться на текущий объект.
   - Особенно важно для функциональных конструкторов и методов классов.

4. **Публичные, частные и статические члены:**
   - Используйте соглашение с символом `_` перед именами частных членов (до появления приватных полей и методов в стандарте ES6).
   - Создавайте статические методы и свойства с помощью ключевого слова `static`.

5. **Прототипное наследование:**
   - Для наследования свойств и методов другого класса или прототипа, используйте `Object.create()` или функции-конструкторы с `Object.setPrototypeOf()`.
   - Используйте `super` в классах для обращения к родительским методам.

6. **Модули:**
   - Используйте модульный паттерн для организации кода и инкапсуляции функциональности.
   - Экспортируйте необходимые функции, методы и классы для публичного использования.

7. **ES6 и дальше:**
   - Используйте классы для определения типов объектов, наследования и методов.
   - Используйте приватные поля и методы с символом `#` для создания настоящих частных членов.

8. **Использование шаблонов проектирования:**
   - Применяйте шаблоны проектирования ООП, такие как фабрика, одиночка, наблюдатель и другие, для решения конкретных задач.

# 11. ECMAScript Classes
### Объявление класса
Объявление класса - это способ определения нового типа объектов в JavaScript с использованием синтаксиса классов, 
представленного в стандарте ECMAScript 2015 (ES6) и более новых версиях. Классы облегчают создание объектов,
определение их свойств и методов, а также реализацию наследования.
### Знать синтаксис объявления класса
Вот базовый синтаксис объявления класса:
```
class ClassName {
  constructor(/* параметры */) {
    // Конструктор, инициализация свойств
  }

  method1(/* параметры */) {
    // Метод 1
  }

  method2(/* параметры */) {
    // Метод 2
  }

  // ...
}
```
Где:

ClassName - имя класса, обычно начинается с заглавной буквы.
constructor - метод-конструктор, вызывается при создании нового объекта.
method1, method2 - методы класса.

### Понимать разницу между классом и функцией конструктора
Классы и функции-конструкторы в JavaScript служат обоим одной цели: они оба используются для 
создания новых типов объектов. Однако синтаксис и подход к определению и созданию объектов различаются. 
Вот основные различия между классами и функциями-конструкторами:

Синтаксис:
Классы (ES6 и выше): Используют синтаксис классов с ключевым словом class. Методы определяются непосредственно внутри класса.
Функции-конструкторы: Определяются как обычные функции, а методы добавляются к прототипу функции.

Создание объектов:
Классы: Создание объектов происходит с использованием ключевого слова new перед именем класса (new ClassName()).
Функции-конструкторы: Также создают объекты с использованием new перед именем функции-конструктора (new ConstructorFunction()).

Прототипы:
Классы: Методы класса добавляются к прототипу объекта-класса. Это позволяет всем экземплярам класса разделять общие методы.
Функции-конструкторы: Методы добавляются к прототипу функции-конструктора.

Соглашение для частных членов:

Классы: В стандарте ES6 и выше появились приватные поля и методы, обозначаемые символом # перед именем (#privateField, #privateMethod).
Функции-конструкторы: До появления приватных полей и методов в ES6, соглашение заключается в добавлении символа _ перед именем (_privateField, _privateMethod).

Статические члены:
Классы: Статические методы и свойства могут быть определены с использованием ключевого слова static.
Функции-конструкторы: Статические методы и свойства также могут быть определены, но через прототип функции.

Наследование:
Классы: Используют ключевое слово extends для наследования свойств и методов от другого класса.
Функции-конструкторы: Используют методы как Object.create() или Object.setPrototypeOf() для наследования.

Современный стандарт:
Классы: Стандарт ES6 и выше вводит синтаксис классов, предоставляя более читаемый и удобный способ определения объектов и наследования.
Функции-конструкторы: Являются более старым подходом к созданию объектов и наследования. Однако они всё ещё широко используются, особенно в старом коде.
### Получатель/установщик
Получатель (Getter):

Getter - это метод объекта, который используется для получения (чтения) значения определенного свойства.
Получатель вызывается при обращении к свойству, как если бы это было обычное свойство объекта.
Пример использования получателя:
```
class Circle {
  constructor(radius) {
    this._radius = radius;
  }

  get radius() {
    return this._radius;
  }

  get area() {
    return Math.PI * this._radius * this._radius;
  }
}

const circle = new Circle(5);
console.log(circle.radius); // Вывод: 5
console.log(circle.area);   // Вывод: 78.53981633974483
```
Установщик (Setter):
Установщик - это метод объекта, который используется для установки (записи) значения определенного свойства. Установщик вызывается при присваивании нового значения свойству.

Пример использования установщика:
```
class Circle {
  constructor(radius) {
    this._radius = radius;
  }

  get radius() {
    return this._radius;
  }

  set radius(newRadius) {
    if (newRadius > 0) {
      this._radius = newRadius;
    }
  }

  get area() {
    return Math.PI * this._radius * this._radius;
  }
}

const circle = new Circle(5);
console.log(circle.radius); // Вывод: 5

circle.radius = 10; // Используем установщик
console.log(circle.radius); // Вывод: 10

circle.radius = -2; // Установка отрицательного значения будет проигнорирована
console.log(circle.radius); // Вывод: 10
```
### Что делает super() и где мы должны его использовать?
super() - это ключевое слово в JavaScript, которое используется для вызова конструктора родительского класса внутри конструктора дочернего класса при наследовании. 
Оно позволяет инициализировать состояние родительского класса, а также передавать аргументы из дочернего класса в конструктор родительского класса.

super() следует использовать в конструкторе дочернего класса и только если этот дочерний класс расширяет другой класс (является подклассом). 
Если класс не имеет своего конструктора, JavaScript автоматически вставит вызов super() без аргументов.

Пример использования super():
```
class Animal {
  constructor(name) {
    this.name = name;
  }

  makeSound() {
    console.log('Some generic animal sound');
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Вызываем конструктор Animal и передаем имя
    this.breed = breed;
  }

  makeSound() {
    console.log('Woof woof!');
  }
}

const myDog = new Dog('Buddy', 'Golden Retriever');
console.log(myDog.name); // Вывод: Buddy
console.log(myDog.breed); // Вывод: Golden Retriever
myDog.makeSound(); // Вывод: Woof woof!
```
В этом примере, super(name) вызывает конструктор родительского класса Animal и передает имя собаки. 
Затем конструктор дочернего класса Dog добавляет дополнительное свойство breed.

# 12. Основы наследования прототипов
### __proto__ свойство
__proto__ - это нестандартное свойство объекта в JavaScript, которое ссылается на прототип этого объекта. Однако начиная с стандарта ECMAScript 2015 (ES6), рекомендуется использовать методы Object.getPrototypeOf() и Object.setPrototypeOf() для работы с прототипами объектов вместо использования __proto__.

Пример использования __proto__ (не рекомендуется, предпочтительнее использовать методы):
```
const parent = {
  greet: function() {
    console.log('Hello from parent');
  }
};

const child = {
  name: 'Child'
};

child.__proto__ = parent; // Наследование прототипа

child.greet(); // Вывод: Hello from parent
```
### [Object.create] и явно определять __proto__
Object.create(proto) - это стандартный метод JavaScript, который создает новый объект с указанным прототипом (proto). 
Этот метод создает новый объект, где прототипом будет объект, переданный в качестве аргумента.
Пример использования Object.create():
```
const protoObj = { x: 10, y: 20 };
const obj = Object.create(protoObj);

console.log(obj.x); // Вывод: 10
console.log(obj.y); // Вывод: 20
```
Явное определение __proto__:
__proto__ - это нестандартное свойство объекта, которое позволяет явно устанавливать прототип объекта. Однако использование __proto__ не рекомендуется, так как оно является устаревшим и может вызвать проблемы совместимости в некоторых окружениях.
Пример явного определения __proto__:
```
const protoObj = { x: 10, y: 20 };
const obj = {};
obj.__proto__ = protoObj;

console.log(obj.x); // Вывод: 10
console.log(obj.y); // Вывод: 20
```
### свойство прототипа
Свойство прототипа (prototype property) - это свойство функции-конструктора в JavaScript, которое определяет прототип, 
который будет использоваться для создания новых объектов при вызове этой функции с ключевым словом new. 
Прототип функции-конструктора содержит методы и свойства, которые наследуются всеми объектами, созданными этой функцией-конструктором.

Вот как выглядит определение свойства прототипа и его использование:
```
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person('Alice');
const person2 = new Person('Bob');

person1.sayHello(); // Вывод: Hello, my name is Alice
person2.sayHello(); // Вывод: Hello, my name is Bob
```
В этом примере, свойство prototype функции-конструктора Person определяет прототип для объектов, созданных с помощью этой функции. 
Метод sayHello добавлен в прототип, и он становится доступным для всех объектов, созданных с использованием Person.
### зависимость между прототипом конструктора функций и экземпляром __proto__
Существует связь между прототипом конструктора функций (через свойство prototype)
и прототипом экземпляра объекта (через свойство __proto__).
Связь между прототипом конструктора и прототипом экземпляра позволяет реализовывать наследование 
и делить общие методы и свойства между несколькими экземплярами одного типа объектов.
### возможность создавать методы "класса", используя свойство прототипа функции
Да, вы можете создавать методы "класса" для функций-конструкторов, используя свойство prototype. 
Эти методы будут доступны всем экземплярам объектов, созданным с использованием этой 
функции-конструктора, посредством наследования через прототип.
```
function Person(name) {
  this.name = name;
}

// Метод "класса" для функции-конструктора Person
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person('Alice');
const person2 = new Person('Bob');

person1.sayHello(); // Вывод: Hello, my name is Alice
person2.sayHello(); // Вывод: Hello, my name is Bob
```
В этом примере, метод sayHello добавляется к прототипу функции-конструктора Person. 
Когда вы создаете объекты с помощью new Person(...), они наследуют метод sayHello, и вы можете вызвать этот метод для каждого созданного объекта.

Таким образом, свойство prototype позволяет создавать общие методы "класса", которые могут быть использованы всеми экземплярами объектов, 
созданными на основе функции-конструктора. Это один из способов реализации наследования и разделения функциональности между объектами одного типа.

Пример создания метода "класса":
```
function Person(name) {
  this.name = name;
}

// Метод "класса" для функции-конструктора Person
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person('Alice');
const person2 = new Person('Bob');

person1.sayHello(); // Вывод: Hello, my name is Alice
person2.sayHello(); // Вывод: Hello, my name is Bob
```

# 13. Расширенные типы данных и выражения ECMAScript
### Set/Map типы данных
Set (Множество) в JavaScript:

Set - это коллекция уникальных значений. Вот как можно использовать Set в JavaScript:

// Создание и использование Set
```
let uniqueNumbers = new Set();
uniqueNumbers.add(1);
uniqueNumbers.add(2);
uniqueNumbers.add(3);
uniqueNumbers.add(2); // Этот элемент не будет добавлен, так как он уже есть в множестве

console.log(uniqueNumbers); // Output: Set { 1, 2, 3 }

// Проверка принадлежности элемента к множеству
console.log(uniqueNumbers.has(2)); // Output: true
console.log(uniqueNumbers.has(4)); // Output: false

// Удаление элемента из множества
uniqueNumbers.delete(2);
console.log(uniqueNumbers); // Output: Set { 1, 3 }
```
Map (Карта) в JavaScript:

Map - это коллекция пар ключ-значение. Вот как можно использовать Map в JavaScript:
```
// Создание и использование Map
let studentScores = new Map();
studentScores.set("Alice", 95);
studentScores.set("Bob", 87);
studentScores.set("Charlie", 92);

console.log(studentScores.get("Alice")); // Output: 95

// Проверка наличия ключа в карте
console.log(studentScores.has("Bob")); // Output: true
console.log(studentScores.has("Eve")); // Output: false

// Удаление записи из карты
studentScores.delete("Bob");
console.log(studentScores); // Output: Map { 'Alice' => 95, 'Charlie' => 92 }
```

### WeakSet/WeakMap типы данных
WeakSet и WeakMap - это специализированные типы данных в JavaScript, которые используются для создания к
оллекций объектов, не предотвращая автоматическое удаление объектов из памяти сборщиком мусора, если они больше не используются в программе. 
Это позволяет избежать утечек памяти в случае, когда объекты, хранящиеся в WeakSet или WeakMap, больше не используются в программе.

WeakSet представляет собой коллекцию слабых ссылок на объекты. Он может содержать только объекты и не поддерживает методы, которые могут вызвать перебор его элементов (например, нет метода forEach или свойства size). Это делается для того, чтобы не влиять на процесс сборки мусора.

Пример использования WeakSet:
```
let weakSet = new WeakSet();

let obj1 = {};
let obj2 = {};

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // Output: true

weakSet.delete(obj1);
console.log(weakSet.has(obj1)); // Output: false
```
WeakMap - это коллекция слабых ссылок на пары ключ-значение, где ключами могут быть только объекты, а значения могут быть произвольными. Как и WeakSet, WeakMap также не поддерживает перебор элементов.

Пример использования WeakMap:

```
let weakMap = new WeakMap();

let key1 = {};
let key2 = {};

weakMap.set(key1, "value1");
weakMap.set(key2, "value2");

console.log(weakMap.get(key1)); // Output: "value1"

weakMap.delete(key1);
console.log(weakMap.has(key1)); // Output: false
```

# 14. JavaScript Ошибки
Ошибки JavaScript (throw, класс ошибок)
В JavaScript ошибки представлены объектами класса Error и его наследниками. 
При возникновении ошибок можно использовать оператор throw для явного создания ошибки и прерывания выполнения кода.

### try..catch
Оператор try...catch в JavaScript используется для обработки исключительных ситуаций (ошибок) в блоках кода. 
Этот оператор позволяет вам написать код, который может вызвать ошибку, и затем ловить и 
обрабатывать эту ошибку без прерывания выполнения всего скрипта.

Синтаксис оператора try...catch выглядит следующим образом:
```
try {
  let result = someFunction(); // Предположим, что someFunction вызывает несуществующую функцию
  console.log(result);
} catch (error) {
  console.error("An error occurred:", error.message);
}
```
### Обработка ошибок
Обработка ошибок в программировании — это важная практика, которая позволяет создавать более надежные и стабильные программы. 
Вот некоторые общие подходы и советы по обработке ошибок:
1. Использование блока try...catch:
Как уже упоминалось, оператор try...catch позволяет ловить и обрабатывать исключения (ошибки) в определенном блоке кода.
Помещайте внутрь блока try тот код, который может вызвать ошибку, а в блоке catch выполняйте обработку ошибки.
2. Использование специфических блоков catch:
В блоке catch можно использовать условные операторы для более детальной обработки разных типов ошибок.
```
try {
  // Код, который может вызвать ошибку
} catch (error) {
  if (error instanceof TypeError) {
    // Обработка ошибки типа TypeError
  } else if (error instanceof RangeError) {
    // Обработка ошибки типа RangeError
  } else {
    // Обработка других ошибок
  }
}
```
3. Логирование ошибок:
Вместо простого вывода сообщений об ошибке на консоль, рекомендуется логировать ошибки в журнал, файл или другой механизм записи. Это позволит отслеживать и анализировать ошибки в реальном времени и в различных средах выполнения.
4. Обработка асинхронных ошибок:
Для асинхронных операций, таких как запросы к серверу или обработка событий, используйте try...catch внутри соответствующих функций или обработчиков.
```
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    // Обработка данных
  } catch (error) {
    // Обработка ошибок
  }
}
```
5. Возврат ошибок:
Вместо простого вывода ошибок на консоль можно возвращать объекты ошибок или использовать механизмы обратных вызовов (callbacks) или обещаний (promises) для более гибкой обработки ошибок.
6. Резервное поведение:
При обработке ошибок также следует предусмотреть резервное поведение (fallback) или альтернативные варианты действий, чтобы при возникновении ошибки программа могла продолжить работу или предоставить пользователю адекватную информацию.
7. Тестирование ошибок:
Регулярное тестирование вашего кода на наличие ошибок позволяет заранее выявлять и исправлять проблемы. Используйте юнит-тесты, интеграционные тесты и другие методы тестирования.
### Класс
Классы - это шаблоны или "чертежи" для создания объектов в объектно-ориентированном программировании (ООП). 
Они представляют собой средство организации кода и данных, позволяя создавать экземпляры объектов с общими свойствами и методами. 
В языке программирования JavaScript классы были введены в стандарте ECMAScript 2015 (ES6).
Классы могут наследовать свойства и методы друг от друга. Класс-потомок (или подкласс) может расширить функциональность родительского класса.

Создание класса и создание объекта на его основе выглядят следующим образом:
```
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

person1.sayHello(); // Output: Hello, my name is Alice and I am 25 years old.
person2.sayHello(); // Output: Hello, my name is Bob and I am 30 years old.
```
### регистрация ошибок
Регистрация ошибок - это процесс сбора и записи информации о возникших ошибках в вашем программном продукте. Это важная практика, которая позволяет отслеживать и анализировать ошибки в реальном времени и обеспечивать более надежное и стабильное функционирование приложения. Вот некоторые шаги и советы по регистрации ошибок:

1. Логирование в файл или базу данных:
Один из наиболее распространенных способов регистрации ошибок - это запись информации об ошибках в журнал (лог). Эти журналы могут храниться в файлах или сохраняться в базе данных. Логирование позволяет сохранять историю ошибок, что полезно при их анализе и отладке.

2. Сохранение контекста:
Помимо самой ошибки, также полезно сохранять информацию о контексте, в котором она возникла. Это может включать данные о состоянии приложения, версии программы, времени выполнения, параметрах запросов и другие полезные детали.

3. Уровни логирования:
Используйте различные уровни логирования, такие как информационные сообщения, предупреждения и критические ошибки. Это позволяет отделить разные типы сообщений и позволяет более точно настраивать уровни детализации логирования.

4. Уникальные идентификаторы ошибок:
Присваивайте каждой ошибке уникальный идентификатор или код. Это упрощает идентификацию конкретных ошибок и поиск связанных с ними записей в логах.

5. Асинхронное логирование:
Регистрация ошибок не должна замедлять выполнение программы. Используйте асинхронные механизмы логирования, чтобы не влиять на производительность приложения.

6. Уведомления и оповещения:
Помимо регистрации ошибок, можно настроить систему уведомлений или оповещений, которая будет сообщать администраторам или разработчикам о возникновении критических ошибок.

7. Анализ и мониторинг:
Анализ логов позволяет выявлять паттерны ошибок, определять их частоту и тенденции. Мониторинг ошибок в реальном времени помогает оперативно реагировать на проблемы.

Пример логирования ошибки в JavaScript:
```
function divide(a, b) {
  try {
    if (b === 0) {
      throw new Error("Division by zero");
    }
    return a / b;
  } catch (error) {
    // Запись ошибки в лог
    console.error("Error:", error.message);
  }
}

console.log(divide(10, 0)); // Output: Error: Division by zero
```


### события асинхронных ошибок
События асинхронных ошибок (asynchronous error events) представляют собой механизм в языке программирования JavaScript для отслеживания и обработки ошибок, которые возникают в асинхронных операциях, таких как обещания (promises), асинхронные функции (async/await) и обработчики событий.

Для обработки асинхронных ошибок используется объект Promise, а точнее метод .catch() для цепочки обещаний или блок try...catch внутри асинхронных функций. Кроме того, в некоторых окружениях, таких как браузеры и Node.js, существует событие unhandledRejection, которое позволяет обнаруживать и обрабатывать асинхронные ошибки, которые не были явно обработаны.

Использование блока try...catch в асинхронной функции:
```
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    if (!response.ok) {
      throw new Error("Network request failed");
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("An error occurred:", error.message);
  }
}
```

### Пользовательские ошибки (необязательно)
Пользовательские ошибки (custom errors) - это специфические типы ошибок, которые вы определяете сами в своем коде. Эти ошибки позволяют вам создавать более информативные и контекстные сообщения об ошибках, а также обеспечивать более точную обработку и отладку ошибок в вашем приложении.

В JavaScript вы можете создавать пользовательские ошибки путем создания классов, наследующихся от базового класса Error. Ваш пользовательский класс ошибки может расширить базовый класс и предоставить дополнительную информацию о возникшей проблеме.

Вот пример создания пользовательской ошибки:
class CustomError extends Error {
  constructor(message, customProperty) {
    super(message);
    this.name = "CustomError";
    this.customProperty = customProperty;
  }
}

// Использование пользовательской ошибки
try {
  throw new CustomError("Something went wrong", "Additional info");
} catch (error) {
  if (error instanceof CustomError) {
    console.error("Custom error:", error.message);
    console.error("Custom property:", error.customProperty);
  } else {
    console.error("An error occurred:", error.message);
  }
}
В этом примере создан класс CustomError, который наследуется от Error. 
Конструктор класса CustomError принимает дополнительный параметр customProperty, который может содержать дополнительную информацию о возникшей ошибке.

# 15. ECMAScript продвинутый 
### Promise
### Состояния promise
### Связывание promise
### promise статические методы
### Сравнивание шаблонов promise и обратного вызова (необязательно)
### Обработка ошибок в цикле событий promises async/await
### Сборщик мусора (концепция) (необязательно)
