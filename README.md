# 1. Объекты Встроенные методы
## 1) Статические методы объекта
Статические методы объекта — это методы, которые принадлежат классу, а не экземплярам этого класса. Они не имеют доступа к атрибутам экземпляров класса и не требуют создания объекта класса для вызова. Статические методы обычно используются для выполнения каких-либо операций, связанных с классом, но не зависящих от его состояния.
Статические методы удобно использовать, когда требуется функциональность, связанная с классом, но не зависящая от его состояния.
```
class MathUtils {
  static add(a, b) {
    return a + b;
  }

  static subtract(a, b) {
    return a - b;
  }
}

// Вызов статических методов
console.log(MathUtils.add(5, 3));       // Вывод: 8
console.log(MathUtils.subtract(10, 4)); // Вывод: 6
```

## 2) Флаги и дескрипторы свойств
#### Дескрипторы свойств 
Флаги и дескрипторы свойств используются для определения и настройки поведения свойств объектов. Они позволяют управлять доступом, изменением и удалением свойств объектов. Вот краткое объяснение каждого из них:

Дескриптор свойства - это объект, который определяет характеристики свойства объекта, такие как:

* value: Значение свойства.

* writable: Можно ли изменять значение свойства.

* enumerable: Будет ли свойство перечисляемым в циклах.

* configurable: Можно ли удалять или изменять дескриптор свойства.

Пример использования дескрипторов свойств:
```
const obj = {};
Object.defineProperty(obj, 'prop', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});
```
#### Флаги 
Флаги свойств - это битовые флаги, которые определяют различные аспекты свойства, такие как:

* writable: Если установлен в false, значение свойства нельзя изменить.

* enumerable: Если установлен в false, свойство не будет перечисляемым в циклах.

* configurable: Если установлен в false, дескриптор свойства не может быть изменен или свойство удалено.

Пример использования флагов свойств:
```
const obj = {
  prop: 42
};
Object.defineProperty(obj, 'prop', {
  writable: false,
  enumerable: true,
  configurable: false
});
```
Использование дескрипторов свойств и флагов свойств позволяет точно настраивать поведение свойств объектов в JavaScript. 
Это может быть полезно, например, для создания "защищенных" свойств, которые нельзя случайно изменить, или для определения специфичных поведений при доступе к свойствам.

## 3) Итерируемые объекты, использование Symbol.iterator(optional)
Создание итерируемых объектов позволяет определить способ, каким образом объект будет перебираться с помощью цикла for...of, ...spread, и других механизмов итерации. 
Для этого используется символ Symbol.iterator.

Давайте рассмотрим пример создания итерируемого объекта:
```
const myIterable = {
  data: [1, 2, 3, 4, 5],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// Используем итерируемый объект
for (const item of myIterable) {
  console.log(item);
}
```
В этом примере объект myIterable становится итерируемым благодаря методу, связанному с символом Symbol.iterator. Метод next этого итератора возвращает объект с двумя свойствами: value (значение текущего элемента) и done (логическое значение, показывающее, закончен ли перебор). Когда перебор завершается, done устанавливается в true.

Теперь, если мы выполним цикл for...of или используем оператор spread (...), то мы получим доступ к элементам объекта myIterable.

# 2. Типы данных и выражения ECMAScript
## 1) Вычисляемые свойства объекта 
Вычисляемые свойства объекта (Computed properties) - это особый способ определения свойств объекта, который позволяет использовать выражения в качестве имен свойств. Это позволяет динамически определять свойства объекта на основе вычислений во время выполнения программы.

Давайте рассмотрим пример:
```
const dynamicKey = "age";
const person = {
  name: "John",
  [dynamicKey]: 30, // Вычисляемое свойство
};

console.log(person.name); // Вывод: John
console.log(person.age);  // Вывод: 30
```
В этом примере свойство age объекта person вычисляется динамически с использованием переменной dynamicKey. Таким образом, вы можете создавать свойства, чьи имена определяются в зависимости от контекста или вычислений.

Это может быть полезно, например, когда вы хотите динамически создавать свойства объекта на основе данных или условий в вашей программе.

## 2) Перебор ключей объекта 
Перебор (или итерация) ключей объекта в JavaScript можно осуществить с использованием различных методов. 

Вот несколько способов:
#### 1. Цикл for...in:
   
Цикл for...in позволяет перебрать все перечисляемые свойства объекта, включая его прототип. Обычно используется для перебора ключей объекта.
```
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key); // Выводит: a, b, c
}
```
#### 2. Метод Object.keys():
   
Метод Object.keys() возвращает массив, содержащий все собственные перечисляемые ключи объекта.
```
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // Выводит: ["a", "b", "c"]
```
#### 3. Метод Object.getOwnPropertyNames():
   
Метод Object.getOwnPropertyNames() возвращает массив, содержащий все собственные ключи (включая неперечисляемые) объекта.
```
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.getOwnPropertyNames(obj);
console.log(keys); // Выводит: ["a", "b", "c"]
```
#### 4. Метод Object.getOwnPropertySymbols():
   
Метод Object.getOwnPropertySymbols() возвращает массив всех символьных ключей объекта.
```
const key1 = Symbol("key1");
const key2 = Symbol("key2");
const obj = { [key1]: 1, [key2]: 2 };
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // Выводит массив символьных ключей
```

# 3. Функциональная область

### 1) Глобальная и функциональная области 
#### Глобальная область видимости:
Глобальная область видимости охватывает весь код, который находится за пределами всех функций. Переменные и функции, объявленные в глобальной области видимости, могут быть доступны и использованы в любой части кода.

Пример:
```
const globalVariable = 42;

function globalFunction() {
  console.log(globalVariable);
}

globalFunction(); // Выводит: 42
```
#### Функциональная область видимости:
Функциональная область видимости связана с областью видимости функций. Переменные и функции, объявленные внутри функции, являются локальными для этой функции и не видны за её пределами. Они существуют только внутри своей функции.

Пример:
```
function outerFunction() {
  const outerVariable = "Hello";

  function innerFunction() {
    console.log(outerVariable);
  }

  innerFunction(); // Выводит: Hello
}

outerFunction();
```

### 2) Области видимости переменных 
Основные типы областей видимости:
#### Глобальная область видимости (Global Scope):
Переменные, объявленные вне всех функций, имеют глобальную область видимости. Они могут быть доступны и использованы в любой части кода, включая внутри функций.

Пример:
```
const globalVariable = "I am global";

function someFunction() {
  console.log(globalVariable);
}

someFunction(); // Вывод: I am global
```
#### Функциональная область видимости функции (Function Scope):
Переменные, объявленные внутри функции, имеют функциональная область видимости. Они могут быть использованы только внутри этой функции и не видны за её пределами.

Пример:
```
function myFunction() {
  const localVariable = "I am local";
  console.log(localVariable);
}

myFunction(); // Вывод: I am local
// console.log(localVariable); // Ошибка - переменная не определена
```
#### Блочная область видимости (Block Scope):
Переменные, объявленные с использованием let или const внутри блока кода (например, внутри цикла или условия), имеют блочную область видимости. Они ограничены только этим блоком и не видны за его пределами.

Пример:
```
if (true) {
  let blockVariable = "I am inside a block";
  console.log(blockVariable);
}

// console.log(blockVariable); // Ошибка - переменная не определена
```
#### Область видимости функции с замыканием (Closure Scope):
Функции в JavaScript создают области видимости, и когда функция объявлена внутри другой функции, она может сохранить доступ к переменным своей внешней функции после завершения её выполнения. Это называется замыканием.

Пример:
```
function outerFunction() {
  const outerVariable = "I am outer";

  function innerFunction() {
    console.log(outerVariable);
  }

  return innerFunction;
}

const closure = outerFunction();
closure(); // Вывод: I am outer
```
Корректное управление областями видимости помогает избегать конфликтов имён и обеспечивает правильное взаимодействие между частями кода.

Важно понимать, что переменные, объявленные с использованием ключевого слова var, имеют функциональную область видимости. 
Переменные, объявленные с использованием let и const, имеют блочную область видимости, что означает, что они ограничены только блоком кода 
(например, внутри цикла или условия).

Области видимости влияют на то, какие переменные и функции видны в определенных частях кода, и это важно для управления и избегания конфликтов имён переменных.

### 3) Вложенные области 
Вложенные области видимости - это ситуация, когда одна область видимости находится внутри другой. В JavaScript это означает, что одна функция определена внутри другой, и внутренняя функция имеет доступ к переменным и параметрам внешней функции.

Вложенные области видимости позволяют создавать замыкания, которые позволяют сохранять доступ к переменным и состоянию внешней функции даже после завершения её выполнения. Это чрезвычайно полезный механизм в JavaScript, который используется для создания функций с замыканиями.

Пример вложенных областей видимости с замыканием:
```
function outerFunction() {
  const outerVariable = "I am outer";

  function innerFunction() {
    console.log(outerVariable); // innerFunction имеет доступ к outerVariable
  }

  return innerFunction;
}

const closure = outerFunction();
closure(); // Вывод: I am outer
```
В этом примере функция innerFunction определена внутри функции outerFunction, и она имеет доступ к переменной outerVariable, которая определена во внешней функции. 
Когда мы вызываем outerFunction() и сохраняем результат в closure, мы создаем замыкание, которое запоминает состояние outerVariable даже после завершения выполнения outerFunction.
Вложенные области видимости и замыкания часто используются для создания функций с частично заданными аргументами, асинхронных операций и других паттернов программирования.

